# WARNING: JMH lock is ignored by user request, make sure no other JMH instances are running
# JMH version: 1.37
# VM version: JDK 1.8.0_432, OpenJDK 64-Bit Server VM, 25.432-b06
# VM invoker: /Users/antoniotrovato/Library/Java/JavaVirtualMachines/corretto-1.8.0_432/Contents/Home/jre/bin/java
# VM options: -Djmh.ignoreLock=true -Xms256m -Xmx256m -Djmh.core.it.profile=default
# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: <none>
# Measurement: 5 iterations, 1 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, ***WARNING: Synchronize iterations are disabled!***
# Benchmark mode: Throughput, ops/time
# Benchmark: org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test

# Run progress: 0,00% complete, ETA 00:00:05
# Fork: 1 of 1
The dynamic halt can be used only when the durations of warm-up and measurement iterations are at least 100ms, and when the total amount of iterations within a fork is at least 100.
Iteration   1: 0,019 ops/ms
                 ops:  19,000 #
                 time: 1021196667,000 #

Iteration   2: 0,018 ops/ms
                 ops:  19,000 #
                 time: 1027565792,000 #

Iteration   3: 0,019 ops/ms
                 ops:  19,000 #
                 time: 1009357667,000 #

Iteration   4: 0,019 ops/ms
                 ops:  19,000 #
                 time: 1020915584,000 #

Iteration   5: 0,019 ops/ms
                 ops:  19,000 #
                 time: 1003701291,000 #



Result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test":
  0,019 ±(99.9%) 0,001 ops/ms [Average]
  (min, avg, max) = (0,018, 0,019, 0,019), stdev = 0,001
  CI (99.9%): [0,018, 0,019] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:ops":
  95,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (19,000, 19,000, 19,000), stdev = 0,001
  CI (99.9%): [95,000, 95,000] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:time":
  5082737001,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (1003701291,000, 1016547400,200, 1027565792,000), stdev = 9731603,856
  CI (99.9%): [5082737001,000, 5082737001,000] (assumes normal distribution)


# Run complete. Total time: 00:00:05

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                       Mode  Cnt           Score   Error   Units
BatchSizeSanityTest.test       thrpt    5           0,019 ± 0,001  ops/ms
BatchSizeSanityTest.test:ops   thrpt    5          95,000               #
BatchSizeSanityTest.test:time  thrpt    5  5082737001,000               #
# WARNING: JMH lock is ignored by user request, make sure no other JMH instances are running
# JMH version: 1.37
# VM version: JDK 1.8.0_432, OpenJDK 64-Bit Server VM, 25.432-b06
# VM invoker: /Users/antoniotrovato/Library/Java/JavaVirtualMachines/corretto-1.8.0_432/Contents/Home/jre/bin/java
# VM options: -Djmh.ignoreLock=true -Xms256m -Xmx256m -Djmh.core.it.profile=default
# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: <none>
# Measurement: 5 iterations, 1 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, ***WARNING: Synchronize iterations are disabled!***
# Benchmark mode: Average time, time/op
# Benchmark: org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test

# Run progress: 0,00% complete, ETA 00:00:05
# Fork: 1 of 1
The dynamic halt can be used only when the durations of warm-up and measurement iterations are at least 100ms, and when the total amount of iterations within a fork is at least 100.
Iteration   1: 53,410 ms/op
                 ops:  19,000 #
                 time: 1014894500,000 #

Iteration   2: 53,455 ms/op
                 ops:  19,000 #
                 time: 1015672709,000 #

Iteration   3: 53,428 ms/op
                 ops:  19,000 #
                 time: 1015187083,000 #

Iteration   4: 52,878 ms/op
                 ops:  19,000 #
                 time: 1004692417,000 #

Iteration   5: 53,603 ms/op
                 ops:  19,000 #
                 time: 1018478542,000 #



Result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test":
  53,355 ±(99.9%) 1,068 ms/op [Average]
  (min, avg, max) = (52,878, 53,355, 53,603), stdev = 0,277
  CI (99.9%): [52,287, 54,423] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:ops":
  95,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (19,000, 19,000, 19,000), stdev = 0,001
  CI (99.9%): [95,000, 95,000] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:time":
  5068925251,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (1004692417,000, 1013785050,200, 1018478542,000), stdev = 5278841,596
  CI (99.9%): [5068925251,000, 5068925251,000] (assumes normal distribution)


# Run complete. Total time: 00:00:05

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                      Mode  Cnt           Score   Error  Units
BatchSizeSanityTest.test       avgt    5          53,355 ± 1,068  ms/op
BatchSizeSanityTest.test:ops   avgt    5          95,000              #
BatchSizeSanityTest.test:time  avgt    5  5068925251,000              #
# WARNING: JMH lock is ignored by user request, make sure no other JMH instances are running
# JMH version: 1.37
# VM version: JDK 1.8.0_432, OpenJDK 64-Bit Server VM, 25.432-b06
# VM invoker: /Users/antoniotrovato/Library/Java/JavaVirtualMachines/corretto-1.8.0_432/Contents/Home/jre/bin/java
# VM options: -Djmh.ignoreLock=true -Xms256m -Xmx256m -Djmh.core.it.profile=default
# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: <none>
# Measurement: 5 iterations, 1 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, ***WARNING: Synchronize iterations are disabled!***
# Benchmark mode: Sampling time
# Benchmark: org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test

# Run progress: 0,00% complete, ETA 00:00:05
# Fork: 1 of 1
The dynamic halt can be used only when the durations of warm-up and measurement iterations are at least 100ms, and when the total amount of iterations within a fork is at least 100.
Iteration   1: 52,936 ±(99.9%) 1,434 ms/op
                 ops:     19,000 #
                 p0.00:   50,332 ms/op
                 p0.50:   52,888 ms/op
                 p0.90:   54,985 ms/op
                 p0.95:   54,985 ms/op
                 p0.99:   54,985 ms/op
                 p0.999:  54,985 ms/op
                 p0.9999: 54,985 ms/op
                 p1.00:   54,985 ms/op
                 time:    1008592625,000 #

Iteration   2: 53,108 ±(99.9%) 1,486 ms/op
                 ops:     19,000 #
                 p0.00:   50,659 ms/op
                 p0.50:   53,084 ms/op
                 p0.90:   54,985 ms/op
                 p0.95:   56,361 ms/op
                 p0.99:   56,361 ms/op
                 p0.999:  56,361 ms/op
                 p0.9999: 56,361 ms/op
                 p1.00:   56,361 ms/op
                 time:    1010081625,000 #

Iteration   3: 52,648 ±(99.9%) 1,764 ms/op
                 ops:     20,000 #
                 p0.00:   50,135 ms/op
                 p0.50:   51,937 ms/op
                 p0.90:   55,044 ms/op
                 p0.95:   55,050 ms/op
                 p0.99:   55,050 ms/op
                 p0.999:  55,050 ms/op
                 p0.9999: 55,050 ms/op
                 p1.00:   55,050 ms/op
                 time:    1053927625,000 #

Iteration   4: 53,174 ±(99.9%) 1,566 ms/op
                 ops:     19,000 #
                 p0.00:   50,201 ms/op
                 p0.50:   52,888 ms/op
                 p0.90:   55,050 ms/op
                 p0.95:   55,050 ms/op
                 p0.99:   55,050 ms/op
                 p0.999:  55,050 ms/op
                 p0.9999: 55,050 ms/op
                 p1.00:   55,050 ms/op
                 time:    1011232167,000 #

Iteration   5: 53,284 ±(99.9%) 1,557 ms/op
                 ops:     19,000 #
                 p0.00:   50,332 ms/op
                 p0.50:   53,871 ms/op
                 p0.90:   54,985 ms/op
                 p0.95:   55,247 ms/op
                 p0.99:   55,247 ms/op
                 p0.999:  55,247 ms/op
                 p0.9999: 55,247 ms/op
                 p1.00:   55,247 ms/op
                 time:    1013470333,000 #



Result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test":
  N = 96
  mean =     53,026 ±(99.9%) 0,602 ms/op

  Histogram, ms/op:
    [50,000, 50,500) = 10 
    [50,500, 51,000) = 8 
    [51,000, 51,500) = 7 
    [51,500, 52,000) = 6 
    [52,000, 52,500) = 8 
    [52,500, 53,000) = 9 
    [53,000, 53,500) = 6 
    [53,500, 54,000) = 4 
    [54,000, 54,500) = 7 
    [54,500, 55,000) = 25 
    [55,000, 55,500) = 5 
    [55,500, 56,000) = 0 
    [56,000, 56,500) = 1 

  Percentiles, ms/op:
      p(0,0000) =     50,135 ms/op
     p(50,0000) =     52,986 ms/op
     p(90,0000) =     54,985 ms/op
     p(95,0000) =     55,050 ms/op
     p(99,0000) =     56,361 ms/op
     p(99,9000) =     56,361 ms/op
     p(99,9900) =     56,361 ms/op
     p(99,9990) =     56,361 ms/op
     p(99,9999) =     56,361 ms/op
    p(100,0000) =     56,361 ms/op

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:ops":
  96,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (19,000, 19,200, 20,000), stdev = 0,447
  CI (99.9%): [96,000, 96,000] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:time":
  5097304375,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (1008592625,000, 1019460875,000, 1053927625,000), stdev = 19349704,604
  CI (99.9%): [5097304375,000, 5097304375,000] (assumes normal distribution)


# Run complete. Total time: 00:00:05

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                           Mode  Cnt           Score   Error  Units
BatchSizeSanityTest.test          sample   96          53,026 ± 0,602  ms/op
BatchSizeSanityTest.test:ops      sample    5          96,000              #
BatchSizeSanityTest.test:p0.00    sample               50,135          ms/op
BatchSizeSanityTest.test:p0.50    sample               52,986          ms/op
BatchSizeSanityTest.test:p0.90    sample               54,985          ms/op
BatchSizeSanityTest.test:p0.95    sample               55,050          ms/op
BatchSizeSanityTest.test:p0.99    sample               56,361          ms/op
BatchSizeSanityTest.test:p0.999   sample               56,361          ms/op
BatchSizeSanityTest.test:p0.9999  sample               56,361          ms/op
BatchSizeSanityTest.test:p1.00    sample               56,361          ms/op
BatchSizeSanityTest.test:time     sample    5  5097304375,000              #
# WARNING: JMH lock is ignored by user request, make sure no other JMH instances are running
# JMH version: 1.37
# VM version: JDK 1.8.0_432, OpenJDK 64-Bit Server VM, 25.432-b06
# VM invoker: /Users/antoniotrovato/Library/Java/JavaVirtualMachines/corretto-1.8.0_432/Contents/Home/jre/bin/java
# VM options: -Djmh.ignoreLock=true -Xms256m -Xmx256m -Djmh.core.it.profile=default
# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: <none>
# Measurement: 5 iterations, 1 s each
# Timeout: 10 min per iteration
# Threads: 1 thread
# Benchmark mode: Single shot invocation time
# Benchmark: org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test

# Run progress: 0,00% complete, ETA 00:00:00
# Fork: 1 of 1
The dynamic halt can be used only when the durations of warm-up and measurement iterations are at least 100ms, and when the total amount of iterations within a fork is at least 100.
Iteration   1: 53,797 ms/op
                 ops:  1,000 #
                 time: 53883375,000 #

Iteration   2: 55,037 ms/op
                 ops:  1,000 #
                 time: 55110542,000 #

Iteration   3: 55,028 ms/op
                 ops:  1,000 #
                 time: 55054416,000 #

Iteration   4: 55,526 ms/op
                 ops:  1,000 #
                 time: 55555083,000 #

Iteration   5: 52,463 ms/op
                 ops:  1,000 #
                 time: 52505541,000 #



Result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test":
  N = 5
  mean =     54,370 ±(99.9%) 4,786 ms/op

  Histogram, ms/op:
    [52,000, 52,250) = 0 
    [52,250, 52,500) = 1 
    [52,500, 52,750) = 0 
    [52,750, 53,000) = 0 
    [53,000, 53,250) = 0 
    [53,250, 53,500) = 0 
    [53,500, 53,750) = 0 
    [53,750, 54,000) = 1 
    [54,000, 54,250) = 0 
    [54,250, 54,500) = 0 
    [54,500, 54,750) = 0 
    [54,750, 55,000) = 0 
    [55,000, 55,250) = 2 
    [55,250, 55,500) = 0 
    [55,500, 55,750) = 1 

  Percentiles, ms/op:
      p(0,0000) =     52,463 ms/op
     p(50,0000) =     55,028 ms/op
     p(90,0000) =     55,526 ms/op
     p(95,0000) =     55,526 ms/op
     p(99,0000) =     55,526 ms/op
     p(99,9000) =     55,526 ms/op
     p(99,9900) =     55,526 ms/op
     p(99,9990) =     55,526 ms/op
     p(99,9999) =     55,526 ms/op
    p(100,0000) =     55,526 ms/op

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:ops":
  5,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (1,000, 1,000, 1,000), stdev = 0,001
  CI (99.9%): [5,000, 5,000] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:time":
  272108957,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (52505541,000, 54421791,400, 55555083,000), stdev = 1237017,476
  CI (99.9%): [272108957,000, 272108957,000] (assumes normal distribution)


# Run complete. Total time: 00:00:00

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                      Mode  Cnt          Score   Error  Units
BatchSizeSanityTest.test         ss    5         54,370 ± 4,786  ms/op
BatchSizeSanityTest.test:ops     ss    5          5,000              #
BatchSizeSanityTest.test:time    ss    5  272108957,000              #
# WARNING: JMH lock is ignored by user request, make sure no other JMH instances are running
# JMH version: 1.37
# VM version: JDK 1.8.0_432, OpenJDK 64-Bit Server VM, 25.432-b06
# VM invoker: /Users/antoniotrovato/Library/Java/JavaVirtualMachines/corretto-1.8.0_432/Contents/Home/jre/bin/java
# VM options: -Djmh.ignoreLock=true -Xms256m -Xmx256m -Djmh.core.it.profile=default
# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: <none>
# Measurement: 5 iterations, 1 s each, 10 calls per op
# Timeout: 10 min per iteration
# Threads: 1 thread, ***WARNING: Synchronize iterations are disabled!***
# Benchmark mode: Throughput, ops/time
# Benchmark: org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test

# Run progress: 0,00% complete, ETA 00:00:05
# Fork: 1 of 1
The dynamic halt can be used only when the durations of warm-up and measurement iterations are at least 100ms, and when the total amount of iterations within a fork is at least 100.
Iteration   1: 0,002 ops/ms
                 ops:  19,000 #
                 time: 1010342542,000 #

Iteration   2: 0,002 ops/ms
                 ops:  19,000 #
                 time: 1023753500,000 #

Iteration   3: 0,002 ops/ms
                 ops:  19,000 #
                 time: 1020861042,000 #

Iteration   4: 0,002 ops/ms
                 ops:  20,000 #
                 time: 1051311250,000 #

Iteration   5: 0,002 ops/ms
                 ops:  19,000 #
                 time: 1007566083,000 #



Result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test":
  0,002 ±(99.9%) 0,001 ops/ms [Average]
  (min, avg, max) = (0,002, 0,002, 0,002), stdev = 0,001
  CI (99.9%): [0,002, 0,002] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:ops":
  96,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (19,000, 19,200, 20,000), stdev = 0,447
  CI (99.9%): [96,000, 96,000] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:time":
  5113834417,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (1007566083,000, 1022766883,400, 1051311250,000), stdev = 17355223,280
  CI (99.9%): [5113834417,000, 5113834417,000] (assumes normal distribution)


# Run complete. Total time: 00:00:05

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                       Mode  Cnt           Score    Error   Units
BatchSizeSanityTest.test       thrpt    5           0,002 ±  0,001  ops/ms
BatchSizeSanityTest.test:ops   thrpt    5          96,000                #
BatchSizeSanityTest.test:time  thrpt    5  5113834417,000                #
# WARNING: JMH lock is ignored by user request, make sure no other JMH instances are running
# JMH version: 1.37
# VM version: JDK 1.8.0_432, OpenJDK 64-Bit Server VM, 25.432-b06
# VM invoker: /Users/antoniotrovato/Library/Java/JavaVirtualMachines/corretto-1.8.0_432/Contents/Home/jre/bin/java
# VM options: -Djmh.ignoreLock=true -Xms256m -Xmx256m -Djmh.core.it.profile=default
# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: <none>
# Measurement: 5 iterations, 1 s each, 10 calls per op
# Timeout: 10 min per iteration
# Threads: 1 thread, ***WARNING: Synchronize iterations are disabled!***
# Benchmark mode: Average time, time/op
# Benchmark: org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test

# Run progress: 0,00% complete, ETA 00:00:05
# Fork: 1 of 1
The dynamic halt can be used only when the durations of warm-up and measurement iterations are at least 100ms, and when the total amount of iterations within a fork is at least 100.
Iteration   1: 536,578 ms/op
                 ops:  19,000 #
                 time: 1019685625,000 #

Iteration   2: 535,151 ms/op
                 ops:  19,000 #
                 time: 1016809542,000 #

Iteration   3: 538,901 ms/op
                 ops:  19,000 #
                 time: 1023942792,000 #

Iteration   4: 533,719 ms/op
                 ops:  19,000 #
                 time: 1014084708,000 #

Iteration   5: 540,230 ms/op
                 ops:  19,000 #
                 time: 1026479833,000 #



Result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test":
  536,916 ±(99.9%) 10,255 ms/op [Average]
  (min, avg, max) = (533,719, 536,916, 540,230), stdev = 2,663
  CI (99.9%): [526,660, 547,171] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:ops":
  95,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (19,000, 19,000, 19,000), stdev = 0,001
  CI (99.9%): [95,000, 95,000] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:time":
  5101002500,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (1014084708,000, 1020200500,000, 1026479833,000), stdev = 5064616,880
  CI (99.9%): [5101002500,000, 5101002500,000] (assumes normal distribution)


# Run complete. Total time: 00:00:05

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                      Mode  Cnt           Score    Error  Units
BatchSizeSanityTest.test       avgt    5         536,916 ± 10,255  ms/op
BatchSizeSanityTest.test:ops   avgt    5          95,000               #
BatchSizeSanityTest.test:time  avgt    5  5101002500,000               #
# WARNING: JMH lock is ignored by user request, make sure no other JMH instances are running
# JMH version: 1.37
# VM version: JDK 1.8.0_432, OpenJDK 64-Bit Server VM, 25.432-b06
# VM invoker: /Users/antoniotrovato/Library/Java/JavaVirtualMachines/corretto-1.8.0_432/Contents/Home/jre/bin/java
# VM options: -Djmh.ignoreLock=true -Xms256m -Xmx256m -Djmh.core.it.profile=default
# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: <none>
# Measurement: 5 iterations, 1 s each, 10 calls per op
# Timeout: 10 min per iteration
# Threads: 1 thread, ***WARNING: Synchronize iterations are disabled!***
# Benchmark mode: Sampling time
# Benchmark: org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test

# Run progress: 0,00% complete, ETA 00:00:05
# Fork: 1 of 1
The dynamic halt can be used only when the durations of warm-up and measurement iterations are at least 100ms, and when the total amount of iterations within a fork is at least 100.
Iteration   1: 536,347 ms/op
                 ops:     20,000 #
                 p0.00:   535,822 ms/op
                 p0.50:   536,347 ms/op
                 p0.90:   536,871 ms/op
                 p0.95:   536,871 ms/op
                 p0.99:   536,871 ms/op
                 p0.999:  536,871 ms/op
                 p0.9999: 536,871 ms/op
                 p1.00:   536,871 ms/op
                 time:    1075511208,000 #

Iteration   2: 538,444 ms/op
                 ops:     20,000 #
                 p0.00:   535,822 ms/op
                 p0.50:   538,444 ms/op
                 p0.90:   541,065 ms/op
                 p0.95:   541,065 ms/op
                 p0.99:   541,065 ms/op
                 p0.999:  541,065 ms/op
                 p0.9999: 541,065 ms/op
                 p1.00:   541,065 ms/op
                 time:    1077976209,000 #

Iteration   3: 533,463 ms/op
                 ops:     20,000 #
                 p0.00:   532,152 ms/op
                 p0.50:   533,463 ms/op
                 p0.90:   534,774 ms/op
                 p0.95:   534,774 ms/op
                 p0.99:   534,774 ms/op
                 p0.999:  534,774 ms/op
                 p0.9999: 534,774 ms/op
                 p1.00:   534,774 ms/op
                 time:    1067131625,000 #

Iteration   4: 533,987 ms/op
                 ops:     20,000 #
                 p0.00:   532,677 ms/op
                 p0.50:   533,987 ms/op
                 p0.90:   535,298 ms/op
                 p0.95:   535,298 ms/op
                 p0.99:   535,298 ms/op
                 p0.999:  535,298 ms/op
                 p0.9999: 535,298 ms/op
                 p1.00:   535,298 ms/op
                 time:    1068789459,000 #

Iteration   5: 531,628 ms/op
                 ops:     20,000 #
                 p0.00:   525,337 ms/op
                 p0.50:   531,628 ms/op
                 p0.90:   537,919 ms/op
                 p0.95:   537,919 ms/op
                 p0.99:   537,919 ms/op
                 p0.999:  537,919 ms/op
                 p0.9999: 537,919 ms/op
                 p1.00:   537,919 ms/op
                 time:    1064593125,000 #



Result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test":
  N = 10
  mean =    534,774 ±(99.9%) 6,308 ms/op

  Histogram, ms/op:
    [520,000, 522,500) = 0 
    [522,500, 525,000) = 0 
    [525,000, 527,500) = 1 
    [527,500, 530,000) = 0 
    [530,000, 532,500) = 1 
    [532,500, 535,000) = 2 
    [535,000, 537,500) = 4 
    [537,500, 540,000) = 1 
    [540,000, 542,500) = 1 
    [542,500, 545,000) = 0 
    [545,000, 547,500) = 0 

  Percentiles, ms/op:
      p(0,0000) =    525,337 ms/op
     p(50,0000) =    535,560 ms/op
     p(90,0000) =    540,751 ms/op
     p(95,0000) =    541,065 ms/op
     p(99,0000) =    541,065 ms/op
     p(99,9000) =    541,065 ms/op
     p(99,9900) =    541,065 ms/op
     p(99,9990) =    541,065 ms/op
     p(99,9999) =    541,065 ms/op
    p(100,0000) =    541,065 ms/op

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:ops":
  100,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (20,000, 20,000, 20,000), stdev = 0,001
  CI (99.9%): [100,000, 100,000] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:time":
  5354001626,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (1064593125,000, 1070800325,200, 1077976209,000), stdev = 5694690,585
  CI (99.9%): [5354001626,000, 5354001626,000] (assumes normal distribution)


# Run complete. Total time: 00:00:05

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                           Mode  Cnt           Score   Error  Units
BatchSizeSanityTest.test          sample   10         534,774 ± 6,308  ms/op
BatchSizeSanityTest.test:ops      sample    5         100,000              #
BatchSizeSanityTest.test:p0.00    sample              525,337          ms/op
BatchSizeSanityTest.test:p0.50    sample              535,560          ms/op
BatchSizeSanityTest.test:p0.90    sample              540,751          ms/op
BatchSizeSanityTest.test:p0.95    sample              541,065          ms/op
BatchSizeSanityTest.test:p0.99    sample              541,065          ms/op
BatchSizeSanityTest.test:p0.999   sample              541,065          ms/op
BatchSizeSanityTest.test:p0.9999  sample              541,065          ms/op
BatchSizeSanityTest.test:p1.00    sample              541,065          ms/op
BatchSizeSanityTest.test:time     sample    5  5354001626,000              #
# WARNING: JMH lock is ignored by user request, make sure no other JMH instances are running
# JMH version: 1.37
# VM version: JDK 1.8.0_432, OpenJDK 64-Bit Server VM, 25.432-b06
# VM invoker: /Users/antoniotrovato/Library/Java/JavaVirtualMachines/corretto-1.8.0_432/Contents/Home/jre/bin/java
# VM options: -Djmh.ignoreLock=true -Xms256m -Xmx256m -Djmh.core.it.profile=default
# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: <none>
# Measurement: 5 iterations, 1 s each, 10 calls per op
# Timeout: 10 min per iteration
# Threads: 1 thread
# Benchmark mode: Single shot invocation time
# Benchmark: org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test

# Run progress: 0,00% complete, ETA 00:00:00
# Fork: 1 of 1
The dynamic halt can be used only when the durations of warm-up and measurement iterations are at least 100ms, and when the total amount of iterations within a fork is at least 100.
Iteration   1: 531,096 ms/op
                 ops:  10,000 #
                 time: 531244041,000 #

Iteration   2: 530,788 ms/op
                 ops:  10,000 #
                 time: 530814709,000 #

Iteration   3: 540,661 ms/op
                 ops:  10,000 #
                 time: 540684792,000 #

Iteration   4: 533,398 ms/op
                 ops:  10,000 #
                 time: 533419250,000 #

Iteration   5: 529,818 ms/op
                 ops:  10,000 #
                 time: 529839958,000 #



Result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test":
  N = 5
  mean =    533,152 ±(99.9%) 16,936 ms/op

  Histogram, ms/op:
    [520,000, 522,500) = 0 
    [522,500, 525,000) = 0 
    [525,000, 527,500) = 0 
    [527,500, 530,000) = 1 
    [530,000, 532,500) = 2 
    [532,500, 535,000) = 1 
    [535,000, 537,500) = 0 
    [537,500, 540,000) = 0 
    [540,000, 542,500) = 1 
    [542,500, 545,000) = 0 
    [545,000, 547,500) = 0 

  Percentiles, ms/op:
      p(0,0000) =    529,818 ms/op
     p(50,0000) =    531,096 ms/op
     p(90,0000) =    540,661 ms/op
     p(95,0000) =    540,661 ms/op
     p(99,0000) =    540,661 ms/op
     p(99,9000) =    540,661 ms/op
     p(99,9900) =    540,661 ms/op
     p(99,9990) =    540,661 ms/op
     p(99,9999) =    540,661 ms/op
    p(100,0000) =    540,661 ms/op

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:ops":
  50,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (10,000, 10,000, 10,000), stdev = 0,001
  CI (99.9%): [50,000, 50,000] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:time":
  2666002750,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (529839958,000, 533200550,000, 540684792,000), stdev = 4383932,348
  CI (99.9%): [2666002750,000, 2666002750,000] (assumes normal distribution)


# Run complete. Total time: 00:00:02

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                      Mode  Cnt           Score    Error  Units
BatchSizeSanityTest.test         ss    5         533,152 ± 16,936  ms/op
BatchSizeSanityTest.test:ops     ss    5          50,000               #
BatchSizeSanityTest.test:time    ss    5  2666002750,000               #
# WARNING: JMH lock is ignored by user request, make sure no other JMH instances are running
# JMH version: 1.37
# VM version: JDK 1.8.0_432, OpenJDK 64-Bit Server VM, 25.432-b06
# VM invoker: /Users/antoniotrovato/Library/Java/JavaVirtualMachines/corretto-1.8.0_432/Contents/Home/jre/bin/java
# VM options: -Djmh.ignoreLock=true -Xms256m -Xmx256m -Djmh.core.it.profile=default
# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: <none>
# Measurement: 5 iterations, 1 s each, 100 calls per op
# Timeout: 10 min per iteration
# Threads: 1 thread, ***WARNING: Synchronize iterations are disabled!***
# Benchmark mode: Throughput, ops/time
# Benchmark: org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test

# Run progress: 0,00% complete, ETA 00:00:05
# Fork: 1 of 1
The dynamic halt can be used only when the durations of warm-up and measurement iterations are at least 100ms, and when the total amount of iterations within a fork is at least 100.
Iteration   1: ≈ 10⁻⁴ ops/ms
                 ops:  19,000 #
                 time: 1023134959,000 #

Iteration   2: ≈ 10⁻⁴ ops/ms
                 ops:  19,000 #
                 time: 1019077084,000 #

Iteration   3: ≈ 10⁻⁴ ops/ms
                 ops:  19,000 #
                 time: 1015508000,000 #

Iteration   4: ≈ 10⁻⁴ ops/ms
                 ops:  19,000 #
                 time: 1007203875,000 #

Iteration   5: ≈ 10⁻⁴ ops/ms
                 ops:  20,000 #
                 time: 1058090167,000 #



Result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test":
  ≈ 10⁻⁴ ops/ms

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:ops":
  96,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (19,000, 19,200, 20,000), stdev = 0,447
  CI (99.9%): [96,000, 96,000] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:time":
  5123014085,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (1007203875,000, 1024602817,000, 1058090167,000), stdev = 19618421,326
  CI (99.9%): [5123014085,000, 5123014085,000] (assumes normal distribution)


# Run complete. Total time: 00:00:05

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                       Mode  Cnt           Score    Error   Units
BatchSizeSanityTest.test       thrpt    5          ≈ 10⁻⁴           ops/ms
BatchSizeSanityTest.test:ops   thrpt    5          96,000                #
BatchSizeSanityTest.test:time  thrpt    5  5123014085,000                #
# WARNING: JMH lock is ignored by user request, make sure no other JMH instances are running
# JMH version: 1.37
# VM version: JDK 1.8.0_432, OpenJDK 64-Bit Server VM, 25.432-b06
# VM invoker: /Users/antoniotrovato/Library/Java/JavaVirtualMachines/corretto-1.8.0_432/Contents/Home/jre/bin/java
# VM options: -Djmh.ignoreLock=true -Xms256m -Xmx256m -Djmh.core.it.profile=default
# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: <none>
# Measurement: 5 iterations, 1 s each, 100 calls per op
# Timeout: 10 min per iteration
# Threads: 1 thread, ***WARNING: Synchronize iterations are disabled!***
# Benchmark mode: Average time, time/op
# Benchmark: org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test

# Run progress: 0,00% complete, ETA 00:00:05
# Fork: 1 of 1
The dynamic halt can be used only when the durations of warm-up and measurement iterations are at least 100ms, and when the total amount of iterations within a fork is at least 100.
Iteration   1: 5318,298 ms/op
                 ops:  19,000 #
                 time: 1010601666,000 #

Iteration   2: 5324,860 ms/op
                 ops:  19,000 #
                 time: 1011748667,000 #

Iteration   3: 5386,170 ms/op
                 ops:  19,000 #
                 time: 1023397000,000 #

Iteration   4: 5348,048 ms/op
                 ops:  19,000 #
                 time: 1016152042,000 #

Iteration   5: 5371,173 ms/op
                 ops:  19,000 #
                 time: 1020545708,000 #



Result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test":
  5349,710 ±(99.9%) 112,215 ms/op [Average]
  (min, avg, max) = (5318,298, 5349,710, 5386,170), stdev = 29,142
  CI (99.9%): [5237,495, 5461,925] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:ops":
  95,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (19,000, 19,000, 19,000), stdev = 0,001
  CI (99.9%): [95,000, 95,000] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:time":
  5082445083,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (1010601666,000, 1016489016,600, 1023397000,000), stdev = 5509590,345
  CI (99.9%): [5082445083,000, 5082445083,000] (assumes normal distribution)


# Run complete. Total time: 00:00:05

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                      Mode  Cnt           Score     Error  Units
BatchSizeSanityTest.test       avgt    5        5349,710 ± 112,215  ms/op
BatchSizeSanityTest.test:ops   avgt    5          95,000                #
BatchSizeSanityTest.test:time  avgt    5  5082445083,000                #
# WARNING: JMH lock is ignored by user request, make sure no other JMH instances are running
# JMH version: 1.37
# VM version: JDK 1.8.0_432, OpenJDK 64-Bit Server VM, 25.432-b06
# VM invoker: /Users/antoniotrovato/Library/Java/JavaVirtualMachines/corretto-1.8.0_432/Contents/Home/jre/bin/java
# VM options: -Djmh.ignoreLock=true -Xms256m -Xmx256m -Djmh.core.it.profile=default
# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: <none>
# Measurement: 5 iterations, 1 s each, 100 calls per op
# Timeout: 10 min per iteration
# Threads: 1 thread, ***WARNING: Synchronize iterations are disabled!***
# Benchmark mode: Sampling time
# Benchmark: org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test

# Run progress: 0,00% complete, ETA 00:00:05
# Fork: 1 of 1
The dynamic halt can be used only when the durations of warm-up and measurement iterations are at least 100ms, and when the total amount of iterations within a fork is at least 100.
Iteration   1: 5351,932 ms/op
                 ops:     100,000 #
                 p0.00:   5351,932 ms/op
                 p0.50:   5351,932 ms/op
                 p0.90:   5351,932 ms/op
                 p0.95:   5351,932 ms/op
                 p0.99:   5351,932 ms/op
                 p0.999:  5351,932 ms/op
                 p0.9999: 5351,932 ms/op
                 p1.00:   5351,932 ms/op
                 time:    5359164584,000 #

Iteration   2: 5351,932 ms/op
                 ops:     100,000 #
                 p0.00:   5351,932 ms/op
                 p0.50:   5351,932 ms/op
                 p0.90:   5351,932 ms/op
                 p0.95:   5351,932 ms/op
                 p0.99:   5351,932 ms/op
                 p0.999:  5351,932 ms/op
                 p0.9999: 5351,932 ms/op
                 p1.00:   5351,932 ms/op
                 time:    5352581708,000 #

Iteration   3: 5377,098 ms/op
                 ops:     100,000 #
                 p0.00:   5377,098 ms/op
                 p0.50:   5377,098 ms/op
                 p0.90:   5377,098 ms/op
                 p0.95:   5377,098 ms/op
                 p0.99:   5377,098 ms/op
                 p0.999:  5377,098 ms/op
                 p0.9999: 5377,098 ms/op
                 p1.00:   5377,098 ms/op
                 time:    5378287084,000 #

Iteration   4: 5335,155 ms/op
                 ops:     100,000 #
                 p0.00:   5335,155 ms/op
                 p0.50:   5335,155 ms/op
                 p0.90:   5335,155 ms/op
                 p0.95:   5335,155 ms/op
                 p0.99:   5335,155 ms/op
                 p0.999:  5335,155 ms/op
                 p0.9999: 5335,155 ms/op
                 p1.00:   5335,155 ms/op
                 time:    5337593292,000 #

Iteration   5: 5335,155 ms/op
                 ops:     100,000 #
                 p0.00:   5335,155 ms/op
                 p0.50:   5335,155 ms/op
                 p0.90:   5335,155 ms/op
                 p0.95:   5335,155 ms/op
                 p0.99:   5335,155 ms/op
                 p0.999:  5335,155 ms/op
                 p0.9999: 5335,155 ms/op
                 p1.00:   5335,155 ms/op
                 time:    5343243792,000 #



Result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test":
  N = 5
  mean =   5350,254 ±(99.9%) 66,198 ms/op

  Histogram, ms/op:
    [5330,000, 5335,000) = 0 
    [5335,000, 5340,000) = 2 
    [5340,000, 5345,000) = 0 
    [5345,000, 5350,000) = 0 
    [5350,000, 5355,000) = 2 
    [5355,000, 5360,000) = 0 
    [5360,000, 5365,000) = 0 
    [5365,000, 5370,000) = 0 
    [5370,000, 5375,000) = 0 

  Percentiles, ms/op:
      p(0,0000) =   5335,155 ms/op
     p(50,0000) =   5351,932 ms/op
     p(90,0000) =   5377,098 ms/op
     p(95,0000) =   5377,098 ms/op
     p(99,0000) =   5377,098 ms/op
     p(99,9000) =   5377,098 ms/op
     p(99,9900) =   5377,098 ms/op
     p(99,9990) =   5377,098 ms/op
     p(99,9999) =   5377,098 ms/op
    p(100,0000) =   5377,098 ms/op

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:ops":
  500,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (100,000, 100,000, 100,000), stdev = 0,001
  CI (99.9%): [500,000, 500,000] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:time":
  26770870460,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (5337593292,000, 5354174092,000, 5378287084,000), stdev = 15837230,401
  CI (99.9%): [26770870460,000, 26770870460,000] (assumes normal distribution)


# Run complete. Total time: 00:00:27

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                           Mode  Cnt            Score    Error  Units
BatchSizeSanityTest.test          sample    5         5350,254 ± 66,198  ms/op
BatchSizeSanityTest.test:ops      sample    5          500,000               #
BatchSizeSanityTest.test:p0.00    sample              5335,155           ms/op
BatchSizeSanityTest.test:p0.50    sample              5351,932           ms/op
BatchSizeSanityTest.test:p0.90    sample              5377,098           ms/op
BatchSizeSanityTest.test:p0.95    sample              5377,098           ms/op
BatchSizeSanityTest.test:p0.99    sample              5377,098           ms/op
BatchSizeSanityTest.test:p0.999   sample              5377,098           ms/op
BatchSizeSanityTest.test:p0.9999  sample              5377,098           ms/op
BatchSizeSanityTest.test:p1.00    sample              5377,098           ms/op
BatchSizeSanityTest.test:time     sample    5  26770870460,000               #
# WARNING: JMH lock is ignored by user request, make sure no other JMH instances are running
# JMH version: 1.37
# VM version: JDK 1.8.0_432, OpenJDK 64-Bit Server VM, 25.432-b06
# VM invoker: /Users/antoniotrovato/Library/Java/JavaVirtualMachines/corretto-1.8.0_432/Contents/Home/jre/bin/java
# VM options: -Djmh.ignoreLock=true -Xms256m -Xmx256m -Djmh.core.it.profile=default
# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: <none>
# Measurement: 5 iterations, 1 s each, 100 calls per op
# Timeout: 10 min per iteration
# Threads: 1 thread
# Benchmark mode: Single shot invocation time
# Benchmark: org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test

# Run progress: 0,00% complete, ETA 00:00:00
# Fork: 1 of 1
The dynamic halt can be used only when the durations of warm-up and measurement iterations are at least 100ms, and when the total amount of iterations within a fork is at least 100.
Iteration   1: 5335,455 ms/op
                 ops:  100,000 #
                 time: 5335554125,000 #

Iteration   2: 5346,573 ms/op
                 ops:  100,000 #
                 time: 5346593708,000 #

Iteration   3: 5390,331 ms/op
                 ops:  100,000 #
                 time: 5390354250,000 #

Iteration   4: 5372,964 ms/op
                 ops:  100,000 #
                 time: 5372979292,000 #

Iteration   5: 5378,347 ms/op
                 ops:  100,000 #
                 time: 5378362375,000 #



Result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test":
  N = 5
  mean =   5364,734 ±(99.9%) 88,132 ms/op

  Histogram, ms/op:
    [5330,000, 5335,000) = 0 
    [5335,000, 5340,000) = 1 
    [5340,000, 5345,000) = 0 
    [5345,000, 5350,000) = 1 
    [5350,000, 5355,000) = 0 
    [5355,000, 5360,000) = 0 
    [5360,000, 5365,000) = 0 
    [5365,000, 5370,000) = 0 
    [5370,000, 5375,000) = 1 
    [5375,000, 5380,000) = 1 
    [5380,000, 5385,000) = 0 
    [5385,000, 5390,000) = 0 
    [5390,000, 5395,000) = 1 

  Percentiles, ms/op:
      p(0,0000) =   5335,455 ms/op
     p(50,0000) =   5372,964 ms/op
     p(90,0000) =   5390,331 ms/op
     p(95,0000) =   5390,331 ms/op
     p(99,0000) =   5390,331 ms/op
     p(99,9000) =   5390,331 ms/op
     p(99,9900) =   5390,331 ms/op
     p(99,9990) =   5390,331 ms/op
     p(99,9999) =   5390,331 ms/op
    p(100,0000) =   5390,331 ms/op

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:ops":
  500,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (100,000, 100,000, 100,000), stdev = 0,001
  CI (99.9%): [500,000, 500,000] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.batchsize.BatchSizeSanityTest.test:time":
  26823843750,000 ±(99.9%) 0,001 # [Sum]
  (min, avg, max) = (5335554125,000, 5364768750,000, 5390354250,000), stdev = 22861779,876
  CI (99.9%): [26823843750,000, 26823843750,000] (assumes normal distribution)


# Run complete. Total time: 00:00:27

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                      Mode  Cnt            Score    Error  Units
BatchSizeSanityTest.test         ss    5         5364,734 ± 88,132  ms/op
BatchSizeSanityTest.test:ops     ss    5          500,000               #
BatchSizeSanityTest.test:time    ss    5  26823843750,000               #
