# WARNING: JMH lock is ignored by user request, make sure no other JMH instances are running
# JMH version: 1.37
# VM version: JDK 1.8.0_432, OpenJDK 64-Bit Server VM, 25.432-b06
# VM invoker: /Users/antoniotrovato/Library/Java/JavaVirtualMachines/corretto-1.8.0_432/Contents/Home/jre/bin/java
# VM options: -Djmh.ignoreLock=true -Xms256m -Xmx256m -Djmh.core.it.profile=default
# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 1 s each
# Measurement: 5 iterations, 1 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate

# Run progress: 0,00% complete, ETA 00:00:10
# Fork: 1 of 1
The dynamic halt can be used only when the durations of warm-up and measurement iterations are at least 100ms, and when the total amount of iterations within a fork is at least 100.
# Warmup Iteration   1: 6124777,450 ops/s
# Warmup Iteration   2: 5460209,389 ops/s
# Warmup Iteration   3: 7582122,934 ops/s
# Warmup Iteration   4: 5867000,088 ops/s
# Warmup Iteration   5: 6914009,349 ops/s
Iteration   1: 7547006,889 ops/s
                 gc.alloc.rate:                   0,014 MB/sec
                 gc.alloc.rate.norm:              0,002 B/op
                 gc.churn.PS_Eden_Space:          7269,417 MB/sec
                 gc.churn.PS_Eden_Space.norm:     1010,651 B/op
                 gc.churn.PS_Survivor_Space:      0,031 MB/sec
                 gc.churn.PS_Survivor_Space.norm: 0,004 B/op
                 gc.count:                        87,000 counts
                 gc.time:                         115,000 ms

Iteration   2: 9407224,000 ops/s
                 gc.alloc.rate:                   0,014 MB/sec
                 gc.alloc.rate.norm:              0,002 B/op
                 gc.churn.PS_Eden_Space:          9135,555 MB/sec
                 gc.churn.PS_Eden_Space.norm:     1018,673 B/op
                 gc.churn.PS_Survivor_Space:      0,062 MB/sec
                 gc.churn.PS_Survivor_Space.norm: 0,007 B/op
                 gc.count:                        109,000 counts
                 gc.time:                         66,000 ms

Iteration   3: 9076265,259 ops/s
                 gc.alloc.rate:                   0,014 MB/sec
                 gc.alloc.rate.norm:              0,002 B/op
                 gc.churn.PS_Eden_Space:          8795,703 MB/sec
                 gc.churn.PS_Eden_Space.norm:     1016,361 B/op
                 gc.churn.PS_Survivor_Space:      0,093 MB/sec
                 gc.churn.PS_Survivor_Space.norm: 0,011 B/op
                 gc.count:                        105,000 counts
                 gc.time:                         78,000 ms

Iteration   4: 7594298,634 ops/s
                 gc.alloc.rate:                   0,014 MB/sec
                 gc.alloc.rate.norm:              0,002 B/op
                 gc.churn.PS_Eden_Space:          7348,866 MB/sec
                 gc.churn.PS_Eden_Space.norm:     1015,148 B/op
                 gc.churn.PS_Survivor_Space:      0,062 MB/sec
                 gc.churn.PS_Survivor_Space.norm: 0,009 B/op
                 gc.count:                        88,000 counts
                 gc.time:                         151,000 ms

Iteration   5: 9151824,545 ops/s
                 gc.alloc.rate:                   0,014 MB/sec
                 gc.alloc.rate.norm:              0,002 B/op
                 gc.churn.PS_Eden_Space:          8936,138 MB/sec
                 gc.churn.PS_Eden_Space.norm:     1024,292 B/op
                 gc.churn.PS_Survivor_Space:      0,155 MB/sec
                 gc.churn.PS_Survivor_Space.norm: 0,018 B/op
                 gc.count:                        107,000 counts
                 gc.time:                         70,000 ms



Result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate":
  8555323,865 ±(99.9%) 3493915,382 ops/s [Average]
  (min, avg, max) = (7547006,889, 8555323,865, 9407224,000), stdev = 907358,729
  CI (99.9%): [5061408,483, 12049239,247] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate:gc.alloc.rate":
  0,014 ±(99.9%) 0,001 MB/sec [Average]
  (min, avg, max) = (0,014, 0,014, 0,014), stdev = 0,001
  CI (99.9%): [0,014, 0,015] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate:gc.alloc.rate.norm":
  0,002 ±(99.9%) 0,001 B/op [Average]
  (min, avg, max) = (0,002, 0,002, 0,002), stdev = 0,001
  CI (99.9%): [0,001, 0,002] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate:gc.churn.PS_Eden_Space":
  8297,136 ±(99.9%) 3505,600 MB/sec [Average]
  (min, avg, max) = (7269,417, 8297,136, 9135,555), stdev = 910,393
  CI (99.9%): [4791,536, 11802,736] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate:gc.churn.PS_Eden_Space.norm":
  1017,025 ±(99.9%) 19,265 B/op [Average]
  (min, avg, max) = (1010,651, 1017,025, 1024,292), stdev = 5,003
  CI (99.9%): [997,760, 1036,290] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate:gc.churn.PS_Survivor_Space":
  0,081 ±(99.9%) 0,181 MB/sec [Average]
  (min, avg, max) = (0,031, 0,081, 0,155), stdev = 0,047
  CI (99.9%): [≈ 0, 0,262] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate:gc.churn.PS_Survivor_Space.norm":
  0,010 ±(99.9%) 0,020 B/op [Average]
  (min, avg, max) = (0,004, 0,010, 0,018), stdev = 0,005
  CI (99.9%): [≈ 0, 0,029] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate:gc.count":
  496,000 ±(99.9%) 0,001 counts [Sum]
  (min, avg, max) = (87,000, 99,200, 109,000), stdev = 10,780
  CI (99.9%): [496,000, 496,000] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate:gc.time":
  480,000 ±(99.9%) 0,001 ms [Sum]
  (min, avg, max) = (66,000, 96,000, 151,000), stdev = 36,352
  CI (99.9%): [480,000, 480,000] (assumes normal distribution)


# Run complete. Total time: 00:00:15

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                                                          Mode  Cnt        Score         Error   Units
GCProfilerAllocRateTest.allocate                                  thrpt    5  8555323,865 ± 3493915,382   ops/s
GCProfilerAllocRateTest.allocate:gc.alloc.rate                    thrpt    5        0,014 ±       0,001  MB/sec
GCProfilerAllocRateTest.allocate:gc.alloc.rate.norm               thrpt    5        0,002 ±       0,001    B/op
GCProfilerAllocRateTest.allocate:gc.churn.PS_Eden_Space           thrpt    5     8297,136 ±    3505,600  MB/sec
GCProfilerAllocRateTest.allocate:gc.churn.PS_Eden_Space.norm      thrpt    5     1017,025 ±      19,265    B/op
GCProfilerAllocRateTest.allocate:gc.churn.PS_Survivor_Space       thrpt    5        0,081 ±       0,181  MB/sec
GCProfilerAllocRateTest.allocate:gc.churn.PS_Survivor_Space.norm  thrpt    5        0,010 ±       0,020    B/op
GCProfilerAllocRateTest.allocate:gc.count                         thrpt    5      496,000                counts
GCProfilerAllocRateTest.allocate:gc.time                          thrpt    5      480,000                    ms
# WARNING: JMH lock is ignored by user request, make sure no other JMH instances are running
# JMH version: 1.37
# VM version: JDK 1.8.0_432, OpenJDK 64-Bit Server VM, 25.432-b06
# VM invoker: /Users/antoniotrovato/Library/Java/JavaVirtualMachines/corretto-1.8.0_432/Contents/Home/jre/bin/java
# VM options: -Djmh.ignoreLock=true -Xms256m -Xmx256m -Djmh.core.it.profile=default
# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 1 s each
# Measurement: 5 iterations, 1 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate

# Run progress: 0,00% complete, ETA 00:00:10
# Fork: 1 of 1
The dynamic halt can be used only when the durations of warm-up and measurement iterations are at least 100ms, and when the total amount of iterations within a fork is at least 100.
# Warmup Iteration   1: 6782773,247 ops/s
# Warmup Iteration   2: 7126481,961 ops/s
# Warmup Iteration   3: 9602294,370 ops/s
# Warmup Iteration   4: 6437723,301 ops/s
# Warmup Iteration   5: 8782404,519 ops/s
Iteration   1: 9408802,469 ops/s
                 gc.alloc.rate:      0,012 MB/sec
                 gc.alloc.rate.norm: 0,001 B/op
                 gc.count:           109,000 counts
                 gc.time:            71,000 ms

Iteration   2: 9476470,443 ops/s
                 gc.alloc.rate:      0,012 MB/sec
                 gc.alloc.rate.norm: 0,001 B/op
                 gc.count:           110,000 counts
                 gc.time:            55,000 ms

Iteration   3: 6272704,014 ops/s
                 gc.alloc.rate:      0,012 MB/sec
                 gc.alloc.rate.norm: 0,002 B/op
                 gc.count:           73,000 counts
                 gc.time:            189,000 ms

Iteration   4: 7014943,898 ops/s
                 gc.alloc.rate:      0,012 MB/sec
                 gc.alloc.rate.norm: 0,002 B/op
                 gc.count:           81,000 counts
                 gc.time:            164,000 ms

Iteration   5: 5956129,519 ops/s
                 gc.alloc.rate:      0,012 MB/sec
                 gc.alloc.rate.norm: 0,002 B/op
                 gc.count:           69,000 counts
                 gc.time:            212,000 ms



Result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate":
  7625810,069 ±(99.9%) 6556249,199 ops/s [Average]
  (min, avg, max) = (5956129,519, 7625810,069, 9476470,443), stdev = 1702637,097
  CI (99.9%): [1069560,870, 14182059,268] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate:gc.alloc.rate":
  0,012 ±(99.9%) 0,001 MB/sec [Average]
  (min, avg, max) = (0,012, 0,012, 0,012), stdev = 0,001
  CI (99.9%): [0,012, 0,013] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate:gc.alloc.rate.norm":
  0,002 ±(99.9%) 0,001 B/op [Average]
  (min, avg, max) = (0,001, 0,002, 0,002), stdev = 0,001
  CI (99.9%): [≈ 10⁻³, 0,003] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate:gc.count":
  442,000 ±(99.9%) 0,001 counts [Sum]
  (min, avg, max) = (69,000, 88,400, 110,000), stdev = 19,743
  CI (99.9%): [442,000, 442,000] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate:gc.time":
  691,000 ±(99.9%) 0,001 ms [Sum]
  (min, avg, max) = (55,000, 138,200, 212,000), stdev = 70,942
  CI (99.9%): [691,000, 691,000] (assumes normal distribution)


# Run complete. Total time: 00:00:10

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                                             Mode  Cnt        Score         Error   Units
GCProfilerAllocRateTest.allocate                     thrpt    5  7625810,069 ± 6556249,199   ops/s
GCProfilerAllocRateTest.allocate:gc.alloc.rate       thrpt    5        0,012 ±       0,001  MB/sec
GCProfilerAllocRateTest.allocate:gc.alloc.rate.norm  thrpt    5        0,002 ±       0,001    B/op
GCProfilerAllocRateTest.allocate:gc.count            thrpt    5      442,000                counts
GCProfilerAllocRateTest.allocate:gc.time             thrpt    5      691,000                    ms
# WARNING: JMH lock is ignored by user request, make sure no other JMH instances are running
# JMH version: 1.37
# VM version: JDK 1.8.0_432, OpenJDK 64-Bit Server VM, 25.432-b06
# VM invoker: /Users/antoniotrovato/Library/Java/JavaVirtualMachines/corretto-1.8.0_432/Contents/Home/jre/bin/java
# VM options: -Djmh.ignoreLock=true -Xms256m -Xmx256m -Djmh.core.it.profile=default
# Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)
# Warmup: 5 iterations, 1 s each
# Measurement: 5 iterations, 1 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate

# Run progress: 0,00% complete, ETA 00:00:10
# Fork: 1 of 1
The dynamic halt can be used only when the durations of warm-up and measurement iterations are at least 100ms, and when the total amount of iterations within a fork is at least 100.
# Warmup Iteration   1: 6908078,770 ops/s
# Warmup Iteration   2: 7115853,830 ops/s
# Warmup Iteration   3: 8742289,277 ops/s
# Warmup Iteration   4: 9780156,527 ops/s
# Warmup Iteration   5: 9491096,695 ops/s
Iteration   1: 9359299,193 ops/s
                 gc.alloc.rate:      0,012 MB/sec
                 gc.alloc.rate.norm: 0,001 B/op
                 gc.count:           109,000 counts
                 gc.time:            79,000 ms

Iteration   2: 9717800,183 ops/s
                 gc.alloc.rate:      0,012 MB/sec
                 gc.alloc.rate.norm: 0,001 B/op
                 gc.count:           112,000 counts
                 gc.time:            51,000 ms

Iteration   3: 9891600,033 ops/s
                 gc.alloc.rate:      0,013 MB/sec
                 gc.alloc.rate.norm: 0,001 B/op
                 gc.count:           115,000 counts
                 gc.time:            47,000 ms

Iteration   4: 8906892,522 ops/s
                 gc.alloc.rate:      0,012 MB/sec
                 gc.alloc.rate.norm: 0,001 B/op
                 gc.count:           103,000 counts
                 gc.time:            74,000 ms

Iteration   5: 7999434,607 ops/s
                 gc.alloc.rate:      0,012 MB/sec
                 gc.alloc.rate.norm: 0,002 B/op
                 gc.count:           93,000 counts
                 gc.time:            124,000 ms



Result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate":
  9175005,308 ±(99.9%) 2917323,070 ops/s [Average]
  (min, avg, max) = (7999434,607, 9175005,308, 9891600,033), stdev = 757619,537
  CI (99.9%): [6257682,238, 12092328,377] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate:gc.alloc.rate":
  0,012 ±(99.9%) 0,001 MB/sec [Average]
  (min, avg, max) = (0,012, 0,012, 0,013), stdev = 0,001
  CI (99.9%): [0,012, 0,013] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate:gc.alloc.rate.norm":
  0,001 ±(99.9%) 0,001 B/op [Average]
  (min, avg, max) = (0,001, 0,001, 0,002), stdev = 0,001
  CI (99.9%): [0,001, 0,002] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate:gc.count":
  532,000 ±(99.9%) 0,001 counts [Sum]
  (min, avg, max) = (93,000, 106,400, 115,000), stdev = 8,706
  CI (99.9%): [532,000, 532,000] (assumes normal distribution)

Secondary result "org.openjdk.jmh.it.profilers.GCProfilerAllocRateTest.allocate:gc.time":
  375,000 ±(99.9%) 0,001 ms [Sum]
  (min, avg, max) = (47,000, 75,000, 124,000), stdev = 30,733
  CI (99.9%): [375,000, 375,000] (assumes normal distribution)


# Run complete. Total time: 00:00:10

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                                             Mode  Cnt        Score         Error   Units
GCProfilerAllocRateTest.allocate                     thrpt    5  9175005,308 ± 2917323,070   ops/s
GCProfilerAllocRateTest.allocate:gc.alloc.rate       thrpt    5        0,012 ±       0,001  MB/sec
GCProfilerAllocRateTest.allocate:gc.alloc.rate.norm  thrpt    5        0,001 ±       0,001    B/op
GCProfilerAllocRateTest.allocate:gc.count            thrpt    5      532,000                counts
GCProfilerAllocRateTest.allocate:gc.time             thrpt    5      375,000                    ms
